import { execSync } from "node:child_process";
import { writeFileSync, mkdirSync } from "node:fs";
import { dirname } from "node:path";

function run(cmd) {
  return execSync(cmd, {
    encoding: "utf8",
    stdio: ["ignore", "pipe", "ignore"],
  }).trim();
}

function parseTags(raw) {
  // format: v2.1.0|2026-02-12 00:12:34 +0700
  const lines = raw
    .split("\n")
    .map((l) => l.trim())
    .filter(Boolean);
  const items = [];

  for (const line of lines) {
    const [tag, dateRaw] = line.split("|");
    if (!tag?.startsWith("v")) continue;

    const version = tag.slice(1); // remove 'v'
    // keep only YYYY-MM-DD for stability
    const isoDate = (dateRaw || "").slice(0, 10);
    if (!isoDate) continue;

    items.push({ version, isoDate });
  }

  return items;
}

function semverCmp(a, b) {
  const pa = a.split(".").map((n) => parseInt(n, 10));
  const pb = b.split(".").map((n) => parseInt(n, 10));
  for (let i = 0; i < 3; i++) {
    const da = pa[i] ?? 0;
    const db = pb[i] ?? 0;
    if (da !== db) return da - db;
  }
  return 0;
}

try {
  // Get tags with creator date (works for annotated tags; for lightweight tags, it uses commit date)
  const raw = run(
    'git for-each-ref --sort=-creatordate --format="%(refname:short)|%(creatordate:iso8601)" refs/tags',
  );

  const tags = parseTags(raw);

  // Build date map
  const releaseDates = {};
  for (const t of tags) releaseDates[t.version] = t.isoDate;

  // Compute latest by semver among found versions
  const versions = Object.keys(releaseDates);
  const latestVersion =
    versions.length === 0
      ? ""
      : versions.sort((a, b) => semverCmp(a, b)).at(-1);

  const out = `// AUTO-GENERATED by scripts/generate-release-meta.mjs
// Do not edit manually.

export const releaseDates: Record<string, string> = ${JSON.stringify(releaseDates, null, 2)};

export const latestVersion: string = ${JSON.stringify(latestVersion ?? "")};
`;

  const outPath = "lib/release-meta.ts";
  mkdirSync(dirname(outPath), { recursive: true });
  writeFileSync(outPath, out, "utf8");

  // eslint-disable-next-line no-console
  console.log(
    `[release-meta] generated ${outPath} with ${versions.length} tags`,
  );
} catch (e) {
  // If git tags aren't available (rare), still generate a safe fallback
  const out = `// AUTO-GENERATED fallback (git tags not available)

export const releaseDates: Record<string, string> = {};
export const latestVersion: string = "";
`;
  const outPath = "lib/release-meta.ts";
  mkdirSync(dirname(outPath), { recursive: true });
  writeFileSync(outPath, out, "utf8");
  // eslint-disable-next-line no-console
  console.log("[release-meta] fallback generated (no git tags)");
}
